// 문제: https://www.acmicpc.net/problem/2193
// 동적 계획법: 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구함
// 점화식(일반식)을 세우고 DP테이블(이전 값들을 저장해둠)에 값들을 저장해서 이용하는 방식

// DFS로 풀면 시간초과 (완전탐색을 이용하면 시간초과)
// 아래는 동적 계획법 풀이

#include <iostream>
using namespace std;

int N;
long D[91][2]; // 수가 매우 커질 수 있으므로 long 변수형 사용
// D[i][N]: i 길이에서 끝이 N(0 또는 1)으로 끝나는 이친수의 개수 (i-1번째 끝에서 N(0 또는 1)을 붙였을 때 → 길이 i가 됨)
// D[i][0] = D[i-1][0] + D[i-1][1] → 뒤에 0을 붙이려면 그 앞에가 0 또는 1
// D[i][1] = D[i-1][0] → 뒤에 1을 붙이려면 그 앞에가 1 (11이 연속으로 나올 수 없음)
// 그리고 이친수는 시작이 0이면 안되므로 D[1][0] = 0, D[1][0]을 0으로 설정하기 때문에 맨 앞이 0인 개수는 없음으로 계산됨

int main()
{
	cin >> N;
	
	D[1][0] = 0;
	D[1][1] = 1;
	for (int i = 2; i <= N; i++)
	{
		D[i][0] = D[i - 1][0] + D[i - 1][1];
		D[i][1] = D[i - 1][0];
	}
	
	cout << D[N][0] + D[N][1];
	return 0;
}

// DP는 어떤 점화식을 찾느냐가 관건인듯 (어떻게 작은 문제로 나눠서 큰 문제를 해결할 것인가)
// 규칙을 찾고 수식으로 만드는 게 핵심